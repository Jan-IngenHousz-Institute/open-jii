React Native Component Organization Guidelines

1. Folder Structure
- Each large screen or feature component should live in its own folder.
- Inside that folder, structure it into:
  - components/ → for visual subcomponents (pure UI, reusable only within that screen).
  - hooks/ → for custom hooks containing local state, data fetching, or business logic specific to that screen.
  - utils/ → for helper functions, formatters, or small logic pieces tied to that screen.

2. File Size Limits
- Each file should ideally be ≤ 80 lines.
- Absolute maximum per file: 100 lines.
- If a file grows beyond that, split it into smaller subcomponents, hooks, or utils.

3. Styling Rules
- Each file contains only the styles it directly uses.
- Do not centralize styles into a single styles.ts for the whole app.
- This ensures styles are scoped, relevant, and avoid unnecessary bloat.

4. Component Slicing
- Break large screens into smaller parts:
  - UI-only blocks become subcomponents in components/.
  - Repeated logic or state handling goes into hooks/.
  - Data transformation, constants, and helper logic go into utils/.
- This keeps each unit focused and readable.

5. State-Based Component Slicing (When asked to "slicify")
- Extract different states/conditions into separate components
- Create a components/ subdirectory within the main component folder
- Name components by their state: `NoDeviceState`, `ReadyState`, `ScanningState`, `ResultState`
- Main component becomes an orchestrator that decides which state to render
- Each state component handles its own logic and UI
- Pass necessary props down to state components
- Keep main component clean with simple conditional rendering logic

6. Shared Logic
- If a hook, utility, or component is used across multiple screens, move it into a top-level shared folder (e.g., common/, shared/, hooks/, or utils/ at the app root).
- Avoid duplication across screen folders.

7. Imports and Exports
- Use barrel index.ts files inside screen folders for clean imports.
- No deep imports into components/, hooks/, or utils/ — import through the screen's folder index or the shared top-level folder.
- NEVER create index.ts files unless explicitly requested by the user.

8. Naming & Code Style
- Use dash case for directories and files.
- All component files must use dash-case naming (e.g., `measurement-flow-screen.tsx`, `experiment-selection-step.tsx`).
- Prefer the function keyword to lambda (arrow) for components/helpers.
- Do not add types for things that can be automatically inferred by the TypeScript compiler.
- Avoid comments unless implementing something particularly complex or non-obvious.

9. NativeWind Dark/Light Mode Styling
- Always use the theme system for dark/light mode styling.
- Import `useTheme` and `clsx` in every component that needs styling.
- Use `classes.*` from `useTheme()` for theme-dependent styles.
- Use `colors.*` for theme-dependent colors (automatically selected).
- Use `clsx` for conditional styling logic.

Component Template:
```typescript
import React from "react";
import { View, Text, ActivityIndicator } from "react-native";
import { clsx } from "clsx";
import { useTheme } from "~/hooks/use-theme";

export function ComponentName() {
  const { classes, colors } = useTheme();
  
  return (
    <View className={clsx("p-4 rounded-lg", classes.background)}>
      <Text className={classes.text}>Content</Text>
      <ActivityIndicator color={colors.onPrimary} />
    </View>
  );
}
```

Styling Rules:
- Use `classes.*` for theme-dependent styles
- Use `colors.*` for theme-dependent colors (automatically selected)
- Use `clsx` for conditional logic
- Never hardcode colors or use `dark:` classes
- Always combine base classes with theme classes using `clsx`
