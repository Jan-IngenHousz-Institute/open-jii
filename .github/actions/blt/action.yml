name: "Build, Lint & Test"
description: "Runs build, lint, test, and AsyncAPI generation for affected projects"
inputs:
  node-version:
    description: "Node.js version"
    required: true
    default: "22"
  artifact_retention:
    description: "Artifact retention period in days"
    required: false
    default: "1"
  environment:
    description: "Deployment environment (e.g., dev, staging, production)"
    required: true
  affected_apps:
    description: "JSON array of affected app names"
    required: true
  has_affected_apps:
    description: "Whether there are any affected apps"
    required: true

outputs:
  affected_apps:
    description: "JSON array of affected app names"
    value: ${{ inputs.affected_apps }}
  has_affected_apps:
    description: "Whether there are any affected apps"
    value: ${{ inputs.has_affected_apps }}

runs:
  using: "composite"
  steps:
    - name: Setup pnpm
      uses: pnpm/action-setup@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}
        cache: "pnpm"

    - name: Cache pnpm Store
      uses: actions/cache@v4
      with:
        path: ~/.pnpm-store
        key: ${{ runner.os }}-pnpm-${{ hashFiles('pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-

    - name: Install Dependencies
      shell: bash
      run: pnpm install --frozen-lockfile

    - name: Build Apps
      if: inputs.has_affected_apps == 'true'
      shell: bash
      env:
        DATABASE_URL: ${{ inputs.database_url }}
        AUTH_SECRET: ${{ inputs.auth_secret }}
        AUTH_URL: ${{ inputs.auth_url }}
        AUTH_GITHUB_ID: ${{ inputs.auth_github_id }}
        AUTH_GITHUB_SECRET: ${{ inputs.auth_github_secret }}
      run: |
        echo "üî® Building affected packages"
        # Build command with individual --filter flags for each package
        BUILD_CMD="pnpm turbo run build"
        echo '${{ inputs.affected_apps }}' | jq -r '.[]' | while read -r APP; do
          BUILD_CMD="$BUILD_CMD --filter=$APP"
        done
        echo "Running: $BUILD_CMD"
        eval "$BUILD_CMD"

    - name: Lint Code
      if: inputs.has_affected_apps == 'true'
      shell: bash
      run: |
        echo "üîé Linting affected packages"
        # Lint command with individual --filter flags for each package
        LINT_CMD="pnpm turbo run lint"
        echo '${{ inputs.affected_apps }}' | jq -r '.[]' | while read -r APP; do
          LINT_CMD="$LINT_CMD --filter=$APP"
        done
        echo "Running: $LINT_CMD"
        eval "$LINT_CMD"

    - name: Run Tests
      if: inputs.has_affected_apps == 'true'
      shell: bash
      run: |
        echo "üß™ Testing affected packages"
        # Test command with individual --filter flags for each package
        TEST_CMD="pnpm turbo run test"
        echo '${{ inputs.affected_apps }}' | jq -r '.[]' | while read -r APP; do
          TEST_CMD="$TEST_CMD --filter=$APP"
        done
        echo "Running: $TEST_CMD"
        eval "$TEST_CMD"

    - name: Generate AsyncAPI HTML
      if: inputs.has_affected_apps == 'true'
      shell: bash
      run: |
        echo "üìÑ Generating AsyncAPI documentation"
        pnpm run asyncapi:html

    - name: Collect Build Artifacts
      if: inputs.has_affected_apps == 'true'
      shell: bash
      run: |
        echo "üì¶ Collecting build artifacts"
        # Create artifacts directory if it doesn't exist
        mkdir -p artifacts

        # Process each affected app directly from input
        echo '${{ inputs.affected_apps }}' | jq -r '.[]' | while read -r APP; do
          echo "Collecting artifacts for $APP"
          
          # Determine the build output location based on app directory structure
          if [[ -d "apps/$APP/build" ]]; then
            # Copy from apps/{app}/build
            mkdir -p "artifacts/$APP"
            cp -r "apps/$APP/build/." "artifacts/$APP/"
            echo "‚úÖ Copied from apps/$APP/build"
          elif [[ -d "apps/$APP/dist" ]]; then
            # Copy from apps/{app}/dist
            mkdir -p "artifacts/$APP" 
            cp -r "apps/$APP/dist/." "artifacts/$APP/"
            echo "‚úÖ Copied from apps/$APP/dist"
          elif [[ -d "packages/$APP/build" ]]; then
            # Copy from packages/{app}/build
            mkdir -p "artifacts/$APP"
            cp -r "packages/$APP/build/." "artifacts/$APP/"
            echo "‚úÖ Copied from packages/{app}/build"
          elif [[ -d "packages/$APP/dist" ]]; then
            # Copy from packages/{app}/dist
            mkdir -p "artifacts/$APP"
            cp -r "packages/$APP/dist/." "artifacts/$APP/"
            echo "‚úÖ Copied from packages/{app}/dist"
          else
            echo "‚ùå No build output found for $APP in standard locations"
          fi
        done

        # List collected artifacts for verification
        echo "Collected artifacts in these directories:"
        ls -la artifacts/

    - name: Upload Consolidated Artifacts
      if: inputs.has_affected_apps == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: app-artifacts
        path: artifacts/
        retention-days: ${{ inputs.artifact_retention }}
