# Deploy Next.js App with OpenNext to AWS
# Builds and deploys Next.js application using OpenNext for AWS Lambda/S3/CloudFront

name: Web Deployment Workflow

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "The deployment environment (dev, staging, prod)"
        required: true
        type: string

  workflow_call:
    inputs:
      environment:
        description: "The deployment environment (dev, staging, prod)"
        required: true
        type: string

permissions:
  contents: read

jobs:
  deploy-opennext:
    name: Build & Deploy Next.js with OpenNext
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Capture Deployment Start Time
        id: deployment-start
        run: |
          DEPLOY_START=$(date +%s)
          echo "DEPLOY_START_TIME=$DEPLOY_START" >> $GITHUB_ENV
          echo "deploy_start_time=$DEPLOY_START" >> $GITHUB_OUTPUT
          
          # Get commit timestamp for lead time calculation
          COMMIT_TIME=$(git show -s --format=%ct ${{ github.sha }})
          echo "COMMIT_TIME=$COMMIT_TIME" >> $GITHUB_ENV
          echo "commit_time=$COMMIT_TIME" >> $GITHUB_OUTPUT
          
          echo "üìä DORA Metrics Collection Started"
          echo "  Commit SHA: ${{ github.sha }}"
          echo "  Commit Time: $(date -d @$COMMIT_TIME -u '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r $COMMIT_TIME -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "  Deploy Start: $(date -d @$DEPLOY_START -u '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r $DEPLOY_START -u '+%Y-%m-%d %H:%M:%S UTC')"

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-nodejs-pnpm
        with:
          node-version: "22"
          hoisted: "true"

      - name: Set build environment variables
        env:
          WEB_BASE_ORIGIN: ${{ vars.WEB_BASE_ORIGIN }}
          POSTHOG_KEY: ${{ secrets.POSTHOG_KEY }}
        run: |
          echo "Preparing build-time environment variables..."

          NODE_ENV="production"

          # Public URLs by environment
          if [[ "${{ inputs.environment }}" == "prod" ]]; then
            NEXT_PUBLIC_API_URL="https://api.${WEB_BASE_ORIGIN}"
            NEXT_PUBLIC_DOCS_URL="https://docs.${WEB_BASE_ORIGIN}"
            NEXT_PUBLIC_BASE_URL="https://${WEB_BASE_ORIGIN}"
          else
            NEXT_PUBLIC_API_URL="https://api.dev.${WEB_BASE_ORIGIN}"
            NEXT_PUBLIC_DOCS_URL="https://docs.dev.${WEB_BASE_ORIGIN}"
            NEXT_PUBLIC_BASE_URL="https://dev.${WEB_BASE_ORIGIN}"
          fi

          # PostHog configuration
          NEXT_PUBLIC_POSTHOG_KEY="${POSTHOG_KEY}"
          NEXT_PUBLIC_POSTHOG_HOST="https://eu.i.posthog.com"
          NEXT_PUBLIC_POSTHOG_UI_HOST="https://eu.posthog.com"

          echo "NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_DOCS_URL=${NEXT_PUBLIC_DOCS_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_BASE_URL=${NEXT_PUBLIC_BASE_URL}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_POSTHOG_KEY=${NEXT_PUBLIC_POSTHOG_KEY}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_POSTHOG_HOST=${NEXT_PUBLIC_POSTHOG_HOST}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_POSTHOG_UI_HOST=${NEXT_PUBLIC_POSTHOG_UI_HOST}" >> $GITHUB_ENV
          echo "NODE_ENV=${NODE_ENV}" >> $GITHUB_ENV

      - name: Build Next.js Application
        env:
          NODE_ENV: ${{ env.NODE_ENV }}
          NEXT_PUBLIC_API_URL: ${{ env.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_BASE_URL: ${{ env.NEXT_PUBLIC_BASE_URL }}
          NEXT_PUBLIC_POSTHOG_KEY: ${{ env.NEXT_PUBLIC_POSTHOG_KEY }}
          NEXT_PUBLIC_POSTHOG_HOST: ${{ env.NEXT_PUBLIC_POSTHOG_HOST }}
          NEXT_PUBLIC_POSTHOG_UI_HOST: ${{ env.NEXT_PUBLIC_POSTHOG_UI_HOST }}
        run: |
          echo "Building Next.js application..."
          pnpm run build --filter=web

      - name: Run OpenNext Build
        run: |
          echo "Running OpenNext build..."
          cd apps/web && nice -n 10 pnpm run build:opennext

      - name: Check OpenNext Build Output
        run: |
          echo "Verifying OpenNext build output..."
          if [[ ! -d "apps/web/.open-next" ]]; then
            echo "::error::OpenNext build directory not found: apps/web/.open-next"
            exit 1
          fi
          echo "OpenNext build directory found"

          # Check for server functions
          if [[ -d "apps/web/.open-next/server-functions" ]]; then
            echo "Server function found"
          else
            echo "No server functions found"
          fi

          # Check for image optimization function
          if [[ -d "apps/web/.open-next/image-optimization-function" ]]; then
            echo "Image optimization function found"
          else
            echo "No image optimization function found"
          fi

          # Check for revalidation function
          if [[ -d "apps/web/.open-next/revalidation-function" ]]; then
            echo "Revalidation function found"
          else
            echo "No revalidation function found"
          fi

          # Check for warmer function
          if [[ -d "apps/web/.open-next/warmer-function" ]]; then
            echo "Warmer function found"
          else
            echo "No warmer function found"
          fi

          # Check for dynamodb provider
          if [[ -d "apps/web/.open-next/dynamodb-provider" ]]; then
            echo "DynamoDB provider found"
          else
            echo "No DynamoDB provider found"
          fi

          # Check for assets
          if [[ -d "apps/web/.open-next/assets" ]]; then
            echo "Assets directory found"
          else
            echo "No assets directory found"
          fi

          # Check for cache
          if [[ -d "apps/web/.open-next/cache" ]]; then
            echo "Cache directory found"
          else
            echo "No cache directory found"
          fi

          # Check for OpenNext output JSON
          if [[ -f "apps/web/.open-next/open-next.output.json" ]]; then
            echo "OpenNext output JSON found"
          else
            echo "No OpenNext output JSON found"
          fi

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: true
          role-duration-seconds: 3600 # 1 hour
          output-credentials: true

      - name: Get Infrastructure Configuration
        uses: ./.github/actions/get-infrastructure-config
        with:
          environment: ${{ inputs.environment }}
          prefix: "/opennext"

      - name: Upload Static Assets and Cache to S3
        id: upload-assets
        run: |
          UPLOADED=false
          ASSETS_BUCKET="${{ env.ASSETS_BUCKET }}"
          CACHE_BUCKET="${{ env.CACHE_BUCKET }}"

          # Upload assets to S3
          if [[ -d "apps/web/.open-next/assets" ]]; then
            echo "Uploading static assets to S3..."
            
            # Upload assets with appropriate cache headers
            aws s3 sync apps/web/.open-next/assets/ "s3://${ASSETS_BUCKET}/" \
              --delete \
              --exact-timestamps \
              --cache-control "public, max-age=31536000, immutable" \
              --metadata-directive REPLACE \
              --quiet
            
            # Upload Next.js static files with specific cache headers
            if [[ -d "apps/web/.open-next/assets/_next/static" ]]; then
              echo "Uploading Next.js static files with immutable cache headers..."
              aws s3 sync apps/web/.open-next/assets/_next/static/ "s3://${ASSETS_BUCKET}/_next/static/" \
                --cache-control "public, max-age=31536000, immutable" \
                --metadata-directive REPLACE \
                --quiet
            fi
            
            # Upload other static files with shorter cache
            echo "Uploading other static files with shorter cache duration..."
            aws s3 sync apps/web/.open-next/assets/ "s3://${ASSETS_BUCKET}/" \
              --exclude "_next/static/*" \
              --cache-control "public, max-age=3600" \
              --metadata-directive REPLACE \
              --quiet
            
            UPLOADED=true
            echo "Static assets uploaded successfully"
          else
            echo "No assets directory found in OpenNext build"
          fi

          # Upload cache to S3
          if [[ -d "apps/web/.open-next/cache" && -n "${CACHE_BUCKET}" ]]; then
            echo "Uploading cache to S3..."
            
            # Upload cache with appropriate headers
            aws s3 sync apps/web/.open-next/cache/ "s3://${CACHE_BUCKET}/" \
              --delete \
              --exact-timestamps \
              --quiet
            
            UPLOADED=true
            echo "Cache uploaded successfully"
          else
            echo "No cache directory found in OpenNext build or no cache bucket configured"
          fi

          if [[ "$UPLOADED" == "true" ]]; then
            echo "Asset upload completed successfully"
          else
            echo "No assets were uploaded"
          fi

          echo "uploaded=${UPLOADED}" >> "$GITHUB_OUTPUT"

      - name: Check Server Function
        id: check-server
        run: |
          SERVER_FUNCTION="${{ env.SERVER_FUNCTION }}"
          if [[ -d "apps/web/.open-next/server-functions/default" && -n "${SERVER_FUNCTION}" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Server function found at apps/web/.open-next/server-functions/default"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No server function found or SERVER_FUNCTION not set"
          fi

      - name: Deploy Server Function
        id: deploy-server
        if: steps.check-server.outputs.exists == 'true'
        run: |
          echo "Zipping server function code..."
          cd apps/web/.open-next/server-functions/default
          zip -r ../../server-function.zip .
          cd -
          echo "Uploading server function code to Lambda..."
          UPDATE_OUTPUT=$(aws lambda update-function-code \
            --function-name "${{ env.SERVER_FUNCTION }}" \
            --zip-file fileb://apps/web/.open-next/server-function.zip \
            --publish)
          VERSION=$(echo "$UPDATE_OUTPUT" | jq -r '.Version')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Get Previous Server Alias Version
        id: get-server-alias
        run: |
          ALIAS_NAME="live"
          PREV_VERSION=$(aws lambda get-alias --function-name "${{ env.SERVER_FUNCTION }}" --name "$ALIAS_NAME" --query 'FunctionVersion' --output text || echo "")
          echo "prev_version=$PREV_VERSION" >> $GITHUB_OUTPUT
          echo "Current alias version: $PREV_VERSION"

      - name: Wait Until Lambda Is Active
        id: wait-lambda-active
        run: |
          FUNCTION_NAME="${{ env.SERVER_FUNCTION }}"
          NEW_VERSION="${{ steps.deploy-server.outputs.version }}"
          echo "Waiting for Lambda $FUNCTION_NAME version $NEW_VERSION to become Active..."
          MAX_ATTEMPTS=30
          SLEEP_SECONDS=2
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATE=$(aws lambda get-function-configuration --function-name "$FUNCTION_NAME" --qualifier "$NEW_VERSION" --query 'State' --output text)
            echo "Current state: $STATE"
            if [[ "$STATE" == "Active" ]]; then
              echo "Lambda is Active."
              break
            fi
            sleep $SLEEP_SECONDS
          done
          if [[ "$STATE" != "Active" ]]; then
            WAITED=$((MAX_ATTEMPTS * SLEEP_SECONDS))
            echo "‚ùå Lambda did not become Active after waiting $WAITED seconds."
            exit 1
          fi

      - name: Health Check New Version (before updating alias)
        id: healthcheck-server
        run: |
          FUNCTION_NAME="${{ env.SERVER_FUNCTION }}"
          NEW_VERSION="${{ steps.deploy-server.outputs.version }}"
          
          echo "Health checking new version $NEW_VERSION (before updating alias)..."
          timeout 30 aws lambda invoke \
            --function-name "$FUNCTION_NAME:$NEW_VERSION" \
            /tmp/response.json
          
          echo "Health check response:"
          cat /tmp/response.json
          
          # Check for errors
          if jq -e '.errorMessage or .errorType' /tmp/response.json > /dev/null; then
            echo "‚ùå Lambda health check failed on new version"
            exit 1
          fi
          
          echo "‚úÖ Health check passed on new version"

      - name: Update Server Alias to New Version
        id: update-server-alias
        if: success()
        run: |
          ALIAS_NAME="live"
          echo "Updating alias '$ALIAS_NAME' to version ${{ steps.deploy-server.outputs.version }}..."
          aws lambda update-alias --function-name "${{ env.SERVER_FUNCTION }}" --name "$ALIAS_NAME" --function-version "${{ steps.deploy-server.outputs.version }}" || \
          aws lambda create-alias --function-name "${{ env.SERVER_FUNCTION }}" --name "$ALIAS_NAME" --function-version "${{ steps.deploy-server.outputs.version }}"
          echo "‚úÖ Alias updated successfully"

      - name: Rollback on Failure
        if: failure() && steps.get-server-alias.outputs.prev_version != ''
        run: |
          ALIAS_NAME="live"
          PREV_VERSION="${{ steps.get-server-alias.outputs.prev_version }}"
          
          echo "‚ùå Deployment failed - rolling back alias to previous version $PREV_VERSION"
          aws lambda update-alias --function-name "${{ env.SERVER_FUNCTION }}" --name "$ALIAS_NAME" --function-version "$PREV_VERSION"
          echo "‚úÖ Rolled back Lambda alias to previous version"
          
          # Also delete the failed version to keep things clean
          NEW_VERSION="${{ steps.deploy-server.outputs.version }}"
          if [[ -n "$NEW_VERSION" && "$NEW_VERSION" != "$PREV_VERSION" ]]; then
            echo "Deleting failed version $NEW_VERSION..."
            aws lambda delete-function --function-name "${{ env.SERVER_FUNCTION }}" --qualifier "$NEW_VERSION" || true
          fi

      - name: Revert S3 Asset Uploads on Failure
        if: failure() && steps.upload-assets.outputs.uploaded == 'true'
        env:
          ASSETS_BUCKET: ${{ env.ASSETS_BUCKET }}
        run: |
          echo "‚ùå Reverting latest S3 asset versions due to failed deployment..."
          # List all latest versions and delete them to expose previous versions
          aws s3api list-object-versions \
            --bucket "$ASSETS_BUCKET" \
            --query 'Versions[?IsLatest==`true`].[Key,VersionId]' \
            --output text | while read KEY VERSION; do
              if [[ -n "$KEY" && -n "$VERSION" ]]; then
                echo "Deleting latest version of $KEY ($VERSION)"
                aws s3api delete-object \
                  --bucket "$ASSETS_BUCKET" \
                  --key "$KEY" \
                  --version-id "$VERSION"
              fi
            done
          echo "‚úÖ S3 asset revert complete"

      
      - name: Prune old Lambda versions (keep 10 latest)
        if: success()
        run: |
          FUNCTION_NAME="${{ env.SERVER_FUNCTION }}"
          KEEP=10
          echo "Pruning old Lambda versions (keeping $KEEP latest)..."
          # Get all versions except $LATEST, sort by version number (numeric), skip the newest $KEEP, and delete the rest
          aws lambda list-versions-by-function --function-name "$FUNCTION_NAME" \
            --query 'Versions[?Version!=`$LATEST`].Version' --output text | \
            tr '\t' '\n' | sort -n | head -n -$KEEP | while read VERSION; do
              if [[ -n "$VERSION" ]]; then
                echo "Deleting old version: $VERSION"
                aws lambda delete-function --function-name "$FUNCTION_NAME" --qualifier "$VERSION"
              fi
            done
          echo "‚úÖ Version pruning complete"

      - name: Check Image Optimization Function
        id: check-image
        run: |
          IMAGE_FUNCTION="${{ env.IMAGE_FUNCTION }}"
          if [[ -d "apps/web/.open-next/image-optimization-function" && -n "${IMAGE_FUNCTION}" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Image optimization function found at apps/web/.open-next/image-optimization-function"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No image optimization function found or IMAGE_FUNCTION not set"
          fi

      - name: Deploy Image Optimization Function
        id: deploy-image
        if: steps.check-image.outputs.exists == 'true'
        run: |
          echo "Zipping image optimization function code..."
          cd apps/web/.open-next/image-optimization-function
          zip -r ../image-optimization-function.zip .
          cd -
          echo "Uploading image optimization function code to Lambda..."
          aws lambda update-function-code \
            --function-name "${{ env.IMAGE_FUNCTION }}" \
            --zip-file fileb://apps/web/.open-next/image-optimization-function.zip \
            --publish

      - name: Check Revalidation Function
        id: check-revalidation
        run: |
          REVALIDATION_FUNCTION="${{ env.REVALIDATION_FUNCTION }}"
          if [[ -d "apps/web/.open-next/revalidation-function" && -n "${REVALIDATION_FUNCTION}" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Revalidation function found at apps/web/.open-next/revalidation-function"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No revalidation function found or REVALIDATION_FUNCTION not set"
          fi

      - name: Deploy Revalidation Function
        id: deploy-revalidation
        if: steps.check-revalidation.outputs.exists == 'true'
        run: |
          echo "Zipping revalidation function code..."
          cd apps/web/.open-next/revalidation-function
          zip -r ../revalidation-function.zip .
          cd -
          echo "Uploading revalidation function code to Lambda..."
          aws lambda update-function-code \
            --function-name "${{ env.REVALIDATION_FUNCTION }}" \
            --zip-file fileb://apps/web/.open-next/revalidation-function.zip \
            --publish

      - name: Check Warmer Function
        id: check-warmer
        run: |
          WARMER_FUNCTION="${{ env.WARMER_FUNCTION }}"
          if [[ -d "apps/web/.open-next/warmer-function" && -n "${WARMER_FUNCTION}" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Warmer function found at apps/web/.open-next/warmer-function"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No warmer function found or WARMER_FUNCTION not set"
          fi

      - name: Deploy Warmer Function
        id: deploy-warmer
        if: steps.check-warmer.outputs.exists == 'true'
        run: |
          echo "Zipping warmer function code..."
          cd apps/web/.open-next/warmer-function
          zip -r ../warmer-function.zip .
          cd -
          echo "Uploading warmer function code to Lambda..."
          aws lambda update-function-code \
            --function-name "${{ env.WARMER_FUNCTION }}" \
            --zip-file fileb://apps/web/.open-next/warmer-function.zip \
            --publish

      - name: Finalize Lambda Deployments and Summarize Results
        id: update-lambdas
        run: |
          UPDATED=false

          if [[ "${{ steps.deploy-server.outcome }}" == "success" || \
                "${{ steps.deploy-image.outcome }}" == "success" || \
                "${{ steps.deploy-revalidation.outcome }}" == "success" || \
                "${{ steps.deploy-warmer.outcome }}" == "success" ]]; then
            UPDATED=true
            echo "At least one Lambda function was updated successfully"
          else
            echo "No Lambda functions were updated"
          fi

          echo "updated=${UPDATED}" >> $GITHUB_OUTPUT
          if [[ "$UPDATED" == "true" ]]; then
            echo "Lambda function updates completed successfully"
          else
            echo "::warning::No Lambda functions were updated"
          fi

      - name: Invalidate CloudFront Distribution
        if: steps.upload-assets.outputs.uploaded == 'true'
        run: |
          CLOUDFRONT_DISTRIBUTION_ID="${{ env.CLOUDFRONT_DISTRIBUTION_ID }}"
          if [[ -n "${CLOUDFRONT_DISTRIBUTION_ID}" ]]; then
            echo "Creating CloudFront invalidation for distribution: ${CLOUDFRONT_DISTRIBUTION_ID}"
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id "${CLOUDFRONT_DISTRIBUTION_ID}" \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text 2>/dev/null)
            
            if [[ -n "${INVALIDATION_ID}" ]]; then
              echo "CloudFront invalidation created with ID: ${INVALIDATION_ID}"
              echo "Waiting for invalidation to complete (this may take several minutes)..."
              
              # Wait for invalidation to complete (improves reliability for immediate testing)
              aws cloudfront wait invalidation-completed \
                --distribution-id "${CLOUDFRONT_DISTRIBUTION_ID}" \
                --id "${INVALIDATION_ID}" 2>/dev/null
              
              echo "‚úÖ CloudFront invalidation completed successfully"
            else
              echo "::warning::Failed to create CloudFront invalidation"
            fi
          else
            echo "::warning::Skipping CloudFront invalidation (no distribution ID provided)"
          fi

      - name: Calculate DORA Metrics
        id: dora-metrics
        if: success()
        run: |
          DEPLOY_END=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START_TIME))
          LEAD_TIME=$((DEPLOY_END - COMMIT_TIME))
          
          # Convert to milliseconds for CloudWatch
          LEAD_TIME_MS=$((LEAD_TIME * 1000))
          
          echo "lead_time_ms=$LEAD_TIME_MS" >> $GITHUB_OUTPUT
          echo "deployment_duration=$DEPLOY_DURATION" >> $GITHUB_OUTPUT
          
          echo "üìä DORA Metrics Calculated:"
          echo "  Lead Time: ${LEAD_TIME}s (${LEAD_TIME_MS}ms)"
          echo "  Deployment Duration: ${DEPLOY_DURATION}s"

      - name: Publish DORA - Deployment Frequency
        if: success()
        uses: ./.github/actions/publish-dora-metric
        with:
          metric-name: 'DeploymentFrequency'
          value: '1'
          unit: 'Count'
          service: 'web'
          environment: ${{ inputs.environment }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Publish DORA - Lead Time
        if: success()
        uses: ./.github/actions/publish-dora-metric
        with:
          metric-name: 'LeadTime'
          value: ${{ steps.dora-metrics.outputs.lead_time_ms }}
          unit: 'Milliseconds'
          service: 'web'
          environment: ${{ inputs.environment }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Publish DORA - Deployment Success
        if: success()
        uses: ./.github/actions/publish-dora-metric
        with:
          metric-name: 'DeploymentSuccess'
          value: '1'
          unit: 'Count'
          service: 'web'
          environment: ${{ inputs.environment }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Publish DORA - Deployment Failed
        if: failure()
        uses: ./.github/actions/publish-dora-metric
        with:
          metric-name: 'DeploymentFailed'
          value: '1'
          unit: 'Count'
          service: 'web'
          environment: ${{ inputs.environment }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deployment Summary
        if: always()
        run: |
          echo ""
          echo "=== OpenNext Deployment Summary ==="
          echo "Environment: ${{ inputs.environment }}"
          echo "Assets Uploaded: ${{ steps.upload-assets.outputs.uploaded }}"
          echo "Lambda Functions Updated: ${{ steps.update-lambdas.outputs.updated }}"

          CLOUDFRONT_DISTRIBUTION_ID="${{ env.CLOUDFRONT_DISTRIBUTION_ID }}"
          if [[ -n "${CLOUDFRONT_DISTRIBUTION_ID}" ]]; then
            echo "CloudFront Distribution: ${CLOUDFRONT_DISTRIBUTION_ID}"
            
            # Get CloudFront domain name
            DOMAIN_NAME=$(aws cloudfront get-distribution \
              --id "${CLOUDFRONT_DISTRIBUTION_ID}" \
              --query 'Distribution.DomainName' \
              --output text 2>/dev/null || echo "")
            
            if [[ -n "${DOMAIN_NAME}" ]]; then
              echo "Application URL: https://${DOMAIN_NAME}"
            fi
          fi

          # Display DORA metrics if available
          if [[ -n "${{ steps.dora-metrics.outputs.lead_time_ms }}" ]]; then
            echo ""
            echo "üìä DORA Metrics Published:"
            echo "  Lead Time: ${{ steps.dora-metrics.outputs.lead_time_ms }}ms"
            echo "  Deployment Duration: ${{ steps.dora-metrics.outputs.deployment_duration }}s"
          fi

          # Check overall deployment success
          if [[ "${{ steps.upload-assets.outputs.uploaded }}" == "true" || "${{ steps.update-lambdas.outputs.updated }}" == "true" ]]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ö†Ô∏è Deployment completed but no changes were applied. Please check logs for details."
          fi
          echo ""
