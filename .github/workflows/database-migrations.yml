# Database Migrations Workflow
# Builds migration container and runs database migrations on ECS

name: Database Migrations Workflow

on:
  workflow_call:
    inputs:
      environment:
        description: "The deployment environment (dev, staging, prod)"
        required: true
        type: string
      timeout_minutes:
        description: "Timeout for migration execution in minutes"
        required: false
        type: number
        default: 10

concurrency:
  group: migrations-${{ github.workflow }}-${{ inputs.environment }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  migrate:
    name: Build & Run Migrations
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    timeout-minutes: 30 # Overall job timeout

    steps:
      - name: Set timeout seconds
        id: set-timeout
        run: |
          echo "seconds=$((${{ inputs.timeout_minutes }} * 60))" >> $GITHUB_OUTPUT
          echo "MIGRATION_TIMEOUT=$((${{ inputs.timeout_minutes }} * 60))" >> $GITHUB_ENV
          echo "Setting migration timeout to $((${{ inputs.timeout_minutes }} * 60)) seconds"
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Get Infrastructure Configuration
        uses: ./.github/actions/get-infrastructure-config
        with:
          environment: ${{ inputs.environment }}
          prefix: "/migration"

      - name: Set derived environment variables
        run: |
          # Set log group name based on environment
          echo "LOG_GROUP_NAME=/aws/ecs/db-migration-runner-${{ inputs.environment }}" >> $GITHUB_ENV

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set environment variables
        run: |
          echo "ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_ENV
          echo "IMAGE_TAG=migrations-$(echo ${{ github.sha }} | cut -c1-7)-$(date +%s)" >> $GITHUB_ENV

          # Get and validate AWS region
          AWS_REGION="${{ secrets.AWS_REGION }}"
          if [[ -z "$AWS_REGION" ]]; then
            echo "::warning::AWS_REGION not set in secrets, using default: eu-central-1"
            echo "AWS_REGION=eu-central-1" >> $GITHUB_ENV
          else
            echo "AWS_REGION=$AWS_REGION" >> $GITHUB_ENV
          fi

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          ECR_REPOSITORY: ${{ env.MIGRATION_RUNNER_ECR_REPOSITORY_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          echo "Building Docker image for database migrations"

          # Check if Dockerfile exists
          DATABASE_DIR="packages/database"
          if [[ ! -f "${DATABASE_DIR}/Dockerfile" ]]; then
            echo "::error::Dockerfile not found at ${DATABASE_DIR}/Dockerfile"
            exit 1
          fi

          # Build image for linux/amd64 platform for AWS ECS compatibility
          echo "Building Docker image for linux/amd64 platform (AWS ECS compatible)"
          docker build \
            --platform linux/amd64 \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f ${DATABASE_DIR}/Dockerfile . > /dev/null

          if [ $? -ne 0 ]; then
            echo "::error::Docker build failed"
            exit 1
          fi

          # Define the full image reference for consistency
          FULL_IMAGE_REF="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          echo "Pushing image to ECR repository"
          docker push $FULL_IMAGE_REF > /dev/null
          if [ $? -ne 0 ]; then
            echo "::error::Failed to push image to ECR"
            exit 1
          fi

          # Add latest tag using AWS ECR put-image command (no need to push again)
          if ! aws ecr put-image --repository-name ${ECR_REPOSITORY} --image-tag latest \
            --image-manifest "$(aws ecr batch-get-image --repository-name ${ECR_REPOSITORY} \
            --image-ids imageTag=${IMAGE_TAG} --query 'images[].imageManifest' --output text)" \
            --region ${AWS_REGION} &>/dev/null; then
            echo "::warning::Failed to tag image as latest, but the version-specific tag was pushed successfully"
          fi

          # Store the full image reference for later use
          echo "full_image_ref=$FULL_IMAGE_REF" >> $GITHUB_OUTPUT

          echo "✅ Successfully built and pushed Docker image"
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Check for already running migration task
        id: check-running
        run: |
          CLUSTER_NAME="${{ env.MIGRATION_RUNNER_ECS_CLUSTER_NAME }}"
          TASK_FAMILY="${{ env.MIGRATION_RUNNER_TASK_DEFINITION_FAMILY }}"

          echo "Checking for already running migration tasks..."

          # Check for running tasks with the same family
          RUNNING_TASKS=$(aws ecs list-tasks \
            --cluster ${CLUSTER_NAME} \
            --family ${TASK_FAMILY} \
            --desired-status RUNNING \
            --query 'taskArns[*]' \
            --output text)

          if [ -n "$RUNNING_TASKS" ]; then
            echo "already_running=true" >> $GITHUB_OUTPUT
            echo "running_tasks=$RUNNING_TASKS" >> $GITHUB_OUTPUT
            echo "::warning::Found already running migration tasks: $RUNNING_TASKS"
          else
            echo "No running migration tasks found. Proceeding with new migration."
            echo "already_running=false" >> $GITHUB_OUTPUT
          fi

      - name: Wait for already running task to complete
        if: steps.check-running.outputs.already_running == 'true'
        run: |
          CLUSTER_NAME="${{ env.MIGRATION_RUNNER_ECS_CLUSTER_NAME }}"
          RUNNING_TASKS="${{ steps.check-running.outputs.running_tasks }}"

          echo "Waiting for running migration task to complete..."

          # Wait for up to 15 minutes for the running task to complete
          timeout 900 aws ecs wait tasks-stopped --cluster ${CLUSTER_NAME} --tasks ${RUNNING_TASKS} || {
            echo "::error::Timeout reached waiting for existing migration to complete"
            exit 1
          }

          echo "Previous migration task completed, can proceed with new migration."

      - name: Fetch current task definition
        id: fetch-task-def
        run: |
          TASK_FAMILY="${{ env.MIGRATION_RUNNER_TASK_DEFINITION_FAMILY }}"
          echo "Fetching current task definition for ${TASK_FAMILY}"

          # Fetch the current task definition
          aws ecs describe-task-definition \
            --task-definition ${TASK_FAMILY} \
            --query 'taskDefinition' \
            --output json > task-definition.json
            
          if [ ! -s task-definition.json ]; then
            echo "::error::Failed to fetch task definition"
            exit 1
          fi

          echo "✓ Successfully fetched task definition"

          # Determine network configuration for the task
          NETWORK_MODE=$(jq -r '.networkMode' task-definition.json)
          echo "Task network mode: $NETWORK_MODE"

          # Create network configuration for task based on network mode
          if [[ "$NETWORK_MODE" == "awsvpc" ]]; then
            # For awsvpc mode, prepare network configuration from available sources
            
            if [[ -n "${{ env.MIGRATION_RUNNER_SUBNETS || '' }}" && -n "${{ env.MIGRATION_RUNNER_SECURITY_GROUP_ID || '' }}" ]]; then
              # Parse subnet list
              SUBNET_LIST=$(echo "${{ env.MIGRATION_RUNNER_SUBNETS }}" | jq -r 'if type == "array" then join(",") else . end' 2>/dev/null || echo "${{ env.MIGRATION_RUNNER_SUBNETS }}")
              
              # Format for JSON if needed
              if [[ -n "$SUBNET_LIST" ]]; then
                if [[ "$SUBNET_LIST" =~ ^\[.*\]$ ]]; then
                  SUBNET_JSON="$SUBNET_LIST"
                else
                  # Convert comma list to JSON array format
                  SUBNET_JSON="[\"$(echo $SUBNET_LIST | sed 's/,/","/g')\"]"
                fi
                
                # Create awsvpc network config
                echo "Creating network config from infrastructure outputs"
                echo "NETWORK_CONFIG={\"awsvpcConfiguration\":{\"subnets\":$SUBNET_JSON,\"securityGroups\":[\"${{ env.MIGRATION_RUNNER_SECURITY_GROUP_ID }}\"],\"assignPublicIp\":\"DISABLED\"}}" >> $GITHUB_ENV
              else
                echo "::error::Subnets are empty, can't create network config"
                exit 1
              fi
            else
              # Try to get network config from service if available
              echo "No subnet/security group from outputs, trying service config"
              SERVICE_ARN=$(aws ecs list-services --cluster ${{ env.MIGRATION_RUNNER_ECS_CLUSTER_NAME }} --family ${{ env.MIGRATION_RUNNER_TASK_DEFINITION_FAMILY }} --query 'serviceArns[0]' --output text 2>/dev/null || echo "")
              
              if [[ -n "$SERVICE_ARN" && "$SERVICE_ARN" != "None" ]]; then
                NETWORK_CONFIG=$(aws ecs describe-services --cluster ${{ env.MIGRATION_RUNNER_ECS_CLUSTER_NAME }} --services "$SERVICE_ARN" --query 'services[0].networkConfiguration' --output json)
                
                if [[ -z "$NETWORK_CONFIG" || "$NETWORK_CONFIG" == "null" || "$NETWORK_CONFIG" == "{}" ]]; then
                  echo "::error::Failed to get network config from service"
                  exit 1
                fi
                
                # Set the network config env var
                echo "NETWORK_CONFIG=$NETWORK_CONFIG" >> $GITHUB_ENV
              else
                echo "::error::No network configuration available for awsvpc task"
                echo "::error::Please define subnets and security group in infrastructure"
                exit 1
              fi
            fi
          else
            # For bridge/host network modes, empty config is fine
            echo "Task doesn't use awsvpc networking mode"
            echo "NETWORK_CONFIG={}" >> $GITHUB_ENV
          fi

          # Check if ECR repository exists before proceeding
          AWS_REGION="${{ secrets.AWS_REGION }}"
          ECR_REPO="${{ env.MIGRATION_RUNNER_ECR_REPOSITORY_NAME }}"

          if ! aws ecr describe-repositories --repository-names "${ECR_REPO}" --region ${AWS_REGION} &> /dev/null; then
            echo "::error::ECR repository ${ECR_REPO} does not exist."
            exit 1
          fi

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: render-task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.MIGRATION_RUNNER_CONTAINER_NAME }}
          image: ${{ steps.build-image.outputs.full_image_ref }}

      - name: Run migration task
        id: run-task
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.render-task-def.outputs.task-definition }}
          cluster: ${{ env.MIGRATION_RUNNER_ECS_CLUSTER_NAME }}
          wait-for-service-stability: false
          run-task: true
          wait-for-task-stopped: true
          wait-for-task-timeout: ${{ env.MIGRATION_TIMEOUT }}
          run-task-network-configuration: ${{ env.NETWORK_CONFIG }}

      - name: Migration Summary
        if: always()
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          RUN_TASK_OUTCOME: ${{ steps.run-task.outcome }}
        run: |
          echo "=== Database Migration Summary ==="
          echo "Environment: ${{ inputs.environment }}"
          echo "Image tag: $IMAGE_TAG"
          echo "Task action outcome: $RUN_TASK_OUTCOME"

          if [[ "$RUN_TASK_OUTCOME" == "success" ]]; then
            echo "Status: SUCCESS"
            echo "✅ Migration completed successfully!"
          else
            echo "Status: FAILED"
            echo "To debug this issue:"
            echo "1. Check the CloudWatch logs in AWS Console:"
            echo "   Log Group: /aws/ecs/db-migration-runner-${{ inputs.environment }}"
            echo "2. Try running the migration locally with:"
            echo "   ./database-migrations.sh --dry-run ${{ inputs.environment }}"
            echo "   ./database-migrations.sh ${{ inputs.environment }} ${{ inputs.timeout_minutes }}"
          fi
